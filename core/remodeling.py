# project/core/remodeling.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, Tuple
import numpy as np


@dataclass
class QuadraticRemodeling:
    """
    Quadratic remodeling for standard ASGD linear semantics:

      x_{t+1} = x_t - eta * (1/K) * sum_k H x_{t-d_k}

    State: s_t = [x_t, x_{t-1}, ..., x_{t-D}] in R^{(D+1)n}

    A(d) depends on delay vector only via counts m[j]=#{k: d_k=j}.
    We cache by m-tuple.
    """
    H: np.ndarray  # (n,n), SPD
    eta: float
    D: int
    K: int

    def __post_init__(self):
        self.H = np.array(self.H, copy=True)
        n = self.H.shape[0]
        if self.H.shape != (n, n):
            raise ValueError("H must be square.")
        self._cache: Dict[Tuple[int, ...], np.ndarray] = {}

    def delay_to_counts(self, d: np.ndarray) -> np.ndarray:
        m = np.zeros(self.D + 1, dtype=int)
        for dj in d:
            jj = int(dj)
            if jj < 0 or jj > self.D:
                raise ValueError("delay out of range.")
            m[jj] += 1
        if int(np.sum(m)) != self.K:
            raise ValueError("delay length does not match K.")
        return m

    def get_A_from_counts(self, m: np.ndarray) -> np.ndarray:
        key = tuple(int(x) for x in m)
        if key in self._cache:
            return self._cache[key]

        n = self.H.shape[0]
        D = self.D
        K = self.K

        A = np.zeros(((D + 1) * n, (D + 1) * n), dtype=float)

        # Top block row: [B0, B1, ..., BD]
        for j in range(D + 1):
            coeff = (-self.eta * (m[j] / K)) * self.H
            if j == 0:
                coeff = np.eye(n) + coeff  # I - eta*(m0/K)*H
            A[0:n, j * n:(j + 1) * n] = coeff

        # Shift blocks
        for i in range(1, D + 1):
            A[i * n:(i + 1) * n, (i - 1) * n:i * n] = np.eye(n)

        self._cache[key] = A
        return A

    def triangularization_certificate(self) -> np.ndarray:
        """
        Construct a common basis T = I_{D+1} ⊗ U^T where H = U Λ U^T (eigh),
        which block-diagonalizes (hence triangularizes) all A(d) generated by this remodeling.
        This is a *constructive certificate* (not a heuristic check).
        """
        # For SPD (or symmetric) H, use eigh
        w, U = np.linalg.eigh(self.H)
        # T = kron(I, U^T)
        T = np.kron(np.eye(self.D + 1), U.T)
        return T
    
    # --- QuadraticRemodeling get_A_from_hist + get_A accepts delay/hist ---

    def _hist_from_delay(self, d: np.ndarray) -> np.ndarray:
        d = np.asarray(d, dtype=int).reshape(-1)
        K = int(self.K)
        D = int(self.D)
        if d.shape[0] != K:
            raise ValueError(f"delay vector must have length K={K}, got {d.shape[0]}")
        m = np.zeros(D + 1, dtype=int)
        for dk in d.tolist():
            m[int(dk)] += 1
        return m


    def get_A_from_hist(self, m: np.ndarray) -> np.ndarray:
        """
        Build lifted ASGD matrix A(m) from histogram m=(m0..mD).

        Block form (each block is n x n):
        top row: [I - alpha*m0*H,   -alpha*m1*H, ..., -alpha*mD*H]
        shift rows: z_{t+1}[j] = z_t[j-1]  => identity on subdiagonal
        where alpha = eta / K.
        """
        m = np.asarray(m, dtype=int).reshape(-1)
        D = int(self.D)
        K = int(self.K)
        if m.shape[0] != D + 1:
            raise ValueError(f"histogram must have length D+1={D+1}, got {m.shape[0]}")
        if int(np.sum(m)) != K:
            raise ValueError(f"histogram must satisfy sum(m)=K={K}, got {int(np.sum(m))}")

        H = np.asarray(self.H, dtype=float)
        n = int(H.shape[0])
        alpha = float(self.eta) / float(K)

        I = np.eye(n, dtype=float)
        Z = np.zeros((n, n), dtype=float)

        # allocate big matrix
        m_big = (D + 1) * n
        A = np.zeros((m_big, m_big), dtype=float)

        # top row blocks
        for j in range(D + 1):
            block = (-alpha * float(m[j])) * H
            if j == 0:
                block = I + block  # I - alpha*m0*H
            r0 = 0
            c0 = j * n
            A[r0:r0 + n, c0:c0 + n] = block

        # shift blocks (subdiagonal identity)
        for j in range(1, D + 1):
            r0 = j * n
            c0 = (j - 1) * n
            A[r0:r0 + n, c0:c0 + n] = I

        return A


    def get_A(self, a: np.ndarray) -> np.ndarray:
        """
        Backward-compatible:
        - if len(a)==K : treat as delay vector d
        - if len(a)==D+1 : treat as histogram m
        """
        a = np.asarray(a, dtype=int).reshape(-1)
        if a.shape[0] == int(self.K):
            m = self._hist_from_delay(a)
            return self.get_A_from_hist(m)
        if a.shape[0] == int(self.D) + 1:
            return self.get_A_from_hist(a)
        raise ValueError("get_A: unsupported action length")

